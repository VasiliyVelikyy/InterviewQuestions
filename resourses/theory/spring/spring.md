# Что такое внедрение зависимостей (Dependency Injection) в Spring Framework?

* Механизм, позволяющий разрешать зависимости между классами на этапе компиляции
* Способ передачи зависимостей в объекты во время выполнения приложения
* Механизм, обеспечивающий безопасность взаимодействия между компонентами приложения
* Техника, используемая для уменьшения размера и сложности исходного кода
  В Spring Framework внедрение зависимостей происходит на этапе выполнения (runtime).

## Объяснение:

Внедрение зависимостей позволяет передавать объекты, которые требуются классу (например, сервисы или репозитории), в
конструктор, метод или напрямую в поле класса. Это облегчает управление зависимостями и улучшает тестируемость кода.
Spring использует контейнер для управления жизненным циклом объектов и их зависимостями, что позволяет разработчикам
сосредоточиться на бизнес-логике приложения, а не на создании и управлении объектами.

## Другие варианты:

* Механизм, позволяющий разрешать зависимости между классами на этапе компиляции — это не совсем верно, так как
  внедрение
  зависимостей происходит во время ***выполнения (runtime)***.
* Механизм, обеспечивающий безопасность взаимодействия между компонентами приложения — хотя внедрение зависимостей может
  косвенно способствовать этому, его основная цель — управление зависимостями.
* Техника, используемая для уменьшения размера и сложности исходного кода — это не основная цель внедрения зависимостей.
  Однако оно может помочь улучшить читаемость и поддерживаемость кода.

## Объяснение:

Spring использует контейнер для управления жизненным циклом бинов (объектов), их созданием и внедрением зависимостей.
Это происходит во время выполнения приложения, когда Spring контейнер создает объекты и разрешает их зависимости.
Когда приложение запускается, Spring сканирует классы, помеченные аннотациями (например, @Component, @Service,
@Repository), и создает экземпляры этих классов. Затем он внедряет необходимые зависимости в соответствии с
конфигурацией (например, через аннотации @Autowired или конструкторы).
Пример:

```java

@Component
public class MyService {
    private final MyRepository myRepository;

    // Внедрение зависимости через конструктор
    @Autowired
    public MyService(MyRepository myRepository) {
        this.myRepository = myRepository;
    }

}
```

В этом примере MyRepository будет внедрён в MyService на этапе выполнения, когда Spring контейнер создаёт экземпляр
MyService и разрешает зависимости.

Жизненным циклом управляет спринг-контейнер. В первую очередь после запуска приложения запускается именно он. После
этого контейнер по необходимости и в соответствии с запросами создает экземпляры бинов и внедряет необходимые
зависимости. И, наконец, бины, связанные с контейнером, уничтожаются когда контейнер завершает свою работу. Поэтому,
если мы хотим выполнить какой-то код во время инстанцирования бина или сразу после завершения работы контейнера, один из
самых доступных нам вариантов это вынести его в специальные init() и destroy() методы.

## Ссылки

* <https://habr.com/ru/articles/658273/>
* <https://habr.com/ru/articles/720794/>

# Что такое стартер в контексте Spring Boot?

* Специальный класс, который запускает приложение Spring Boot
* Компонент, который предоставляет настройки по умолчанию для определенной функциональности
* Модуль для автоматической конфигурации безопасности в приложении
* Инструмент для мониторинга и управления состоянием приложения

Spring Boot стартеры — это специальные зависимости (библиотеки), которые содержат набор других библиотек и конфигураций,
необходимых для определенной задачи. Например, стартеры могут включать зависимости для работы с базами данных,
безопасности, веб-сервисов и других компонентов. Это упрощает настройку проекта, так как разработчик может просто
подключить соответствующий стартер, и необходимые зависимости и конфигурации будут добавлены автоматически.

Пример: spring-boot-starter-web предоставляет всё необходимое для создания веб-приложений, включая зависимости для
использования Spring MVC.

Таким образом, правильный ответ: Компонент, который предоставляет настройки по умолчанию для определенной
функциональности.

# Как стартеры Spring Boot работают изнутри для автоматической конфигурации приложения?

- Они используют механизм рефлексии для динамического создания бинов во время выполнения
- Они применяют принцип инверсии управления для инициализации и настройки компонентов
- Они содержат @Configuration классы, которые Spring Boot автоматически обнаруживает и применяет
- Они напрямую модифицируют код приложения для интеграции необходимых зависимостей

Стартеры Spring Boot работают благодаря механизму автоматической конфигурации и условной загрузки бинов.

Правильный ответ: Они содержат @Configuration классы, которые Spring Boot автоматически обнаруживает и применяет.

Механизм работает следующим образом:

1. Стартеры представляют собой набор зависимостей и конфигураций, которые включают в себя классы с аннотацией
   @Configuration.
2. Эти классы содержат инструкции для создания бинов и настройки компонентов на основе присутствующих в проекте
   зависимостей и конфигураций.
3. Автоматическая конфигурация активируется с помощью аннотации @EnableAutoConfiguration или косвенно через
   @SpringBootApplication.
4. Spring Boot загружает классы конфигурации при запуске приложения, используя механизм условной конфигурации (например,
   через аннотации @ConditionalOnClass, @ConditionalOnMissingBean и другие). Это позволяет активировать компоненты
   только
   при выполнении определенных условий, таких как наличие нужного класса в пути к классам или отсутствие уже созданного
   бина.
   Таким образом, стартеры не модифицируют код приложения напрямую и не используют рефлексию для создания бинов. Они
   следуют принципам инверсии управления, но ключевую роль в автоматической конфигурации играет обнаружение и применение
   @Configuration классов.

## Правильный ответ — Они содержат @Configuration классы, которые Spring Boot автоматически обнаруживает и применяет.

# Какие основные цели использования прокси-объектов в Spring Framework?

1. Реализация внедрения зависимостей и аспектно-ориентированного программирования (AOP): Это главная цель использования
   прокси-объектов в Spring. Прокси-объекты позволяют внедрять дополнительное поведение в существующие объекты без
   необходимости изменения их кода. В контексте AOP это может быть добавление таких аспектов, как транзакции,
   логирование,
   безопасность и другие кросс-функциональные аспекты.

2. Добавление дополнительной безопасности к методам компонентов: Прокси-объекты могут использоваться для внедрения
   аспектов
   безопасности, таких как проверка прав доступа перед выполнением методов. Это позволяет централизованно управлять
   политиками безопасности.
   Остальные варианты:

* Улучшение производительности приложения: Прокси-объекты сами по себе не направлены на улучшение производительности,
  хотя
  в некоторых случаях, например, при использовании кэширования на основе AOP, это может косвенно улучшить
  производительность.

* Оптимизация работы сетевых запросов: Прокси-объекты в Spring не предназначены для оптимизации сетевых запросов
  напрямую.
  Для оптимизации сетевых запросов используются другие техники и инструменты, такие как кэширование, использование
  асинхронных вызовов и другие подходы.

# Основное преимущество внедрения зависимостей (Dependency Injection, DI) в Spring Framework заключается в:

Уменьшение связанности между компонентами

Внедрение зависимостей позволяет создавать более гибкую и поддерживаемую архитектуру, так как компоненты могут
взаимодействовать друг с другом через интерфейсы и зависимости, которые предоставляются извне, а не создаются внутри
самих компонентов. Это снижает степень связности между компонентами, делает код более модульным и упрощает его
тестирование и поддержку.

# Чем отличается автоматическое внедрение зависимостей (Autowiring) от явного внедрения зависимостей в Spring?

- Автоматическое внедрение зависимостей требует явного указания зависимостей в конфигурационных файлах, в то время как
  явное внедрение происходит автоматически
- Автоматическое внедрение зависимостей использует рефлексию для определения зависимостей, в то время как явное
  внедрение требует явного создания и передачи зависимостей
- Автоматическое внедрение зависимостей происходит на этапе выполнения приложения, в то время как явное внедрение должно
  быть определено на этапе компиляции
- Автоматическое внедрение зависимостей позволяет Spring самостоятельно определять и внедрять зависимости, основываясь
  на типах и аннотациях, в то время как явное внедрение требует явного указания зависимостей в конфигурационных файлах
  или коде

Правильный ответ на вопрос о различии между автоматическим внедрением зависимостей (Autowiring) и явным внедрением
зависимостей в Spring:

* Автоматическое внедрение зависимостей позволяет Spring самостоятельно определять и внедрять зависимости, основываясь
  на
  типах и аннотациях, в то время как явное внедрение требует явного указания зависимостей в конфигурационных файлах или
  коде.

## Объяснение:

Автоматическое внедрение зависимостей (Autowiring) позволяет Spring автоматически разрешать и внедрять зависимости,
используя информацию о типах бинов и аннотации, такие как @Autowired. Это упрощает конфигурацию, поскольку разработчику
не нужно явно указывать, как должны быть внедрены зависимости.

Явное внедрение зависимостей требует, чтобы разработчик явно указывал, какие зависимости должны быть внедрены, обычно
через конфигурационные файлы XML или в коде с использованием методов, таких как конструкторы или сеттеры. Это требует
больше ручного контроля и настройки, но может быть более явным и предсказуемым в некоторых случаях.

## Остальные варианты:

* Автоматическое внедрение зависимостей использует рефлексию для определения зависимостей, это верно, но это не основное
  различие, так как явное внедрение также может использовать рефлексию.

* Автоматическое внедрение зависимостей происходит на этапе выполнения приложения, это верно, но явное внедрение также
  может быть конфигурировано в коде, который выполняется на этапе компиляции.

* Явное внедрение определено на этапе компиляции не является точным. Конфигурации могут быть определены на этапе
  компиляции или выполнения, в зависимости от подхода к конфигурации, будь то XML или аннотации в коде.

# Какие основные этапы определяют жизненный цикл бина в Spring Framework?

Основные этапы жизненного цикла бина в Spring Framework включают:

***Инстанцирование, инициализация, уничтожение***

Вот подробное объяснение каждого из этих этапов:

1. Инстанцирование: На этом этапе Spring создает экземпляр бина. Это происходит путем вызова конструктора или фабричного
   метода, в зависимости от конфигурации.

2. Инициализация: После создания бина Spring выполняет инициализацию, которая может включать настройку свойств
   (внедрение зависимостей), установку значений полей и вызов методов инициализации. Это может быть выполнено
   автоматически через
   аннотации (@PostConstruct) или в соответствии с конфигурацией в XML или Java-коде.

3. Уничтожение: На последнем этапе жизненного цикла, когда бин больше не нужен, Spring выполняет процесс его
   уничтожения.
   Это может включать вызов методов уничтожения (@PreDestroy) и освобождение ресурсов, используемых бин. Этот этап
   гарантирует, что ресурсы будут корректно освобождены.

## Отличия  ```Инстанцирование, инициализация, уничтожение``` от ```Создание, использование, уничтожение```

Создание, использование, уничтожение: Этот вариант охватывает основные стадии жизненного цикла, но не указывает явно на
инициализацию после создания.

# Какие способы существуют для обхода закольцованных зависимостей (circular dependencies) в Spring Framework?

- Использование аннотации @CircularDependency
- Изменение порядка объявления бинов в конфигурационном файле
- Внедрение зависимости через методы вместо конструкторов
- Рефакторинг приложения для избегания циклических зависимостей

Существуют несколько способов обхода закольцованных зависимостей (circular dependencies). Вот
основные из них:

* Внедрение зависимости через методы вместо конструкторов: Этот подход позволяет решить проблему закольцованных
  зависимостей, так как Spring может создать бины и затем внедрить зависимости через сеттеры или методы, когда бины уже
  частично инициализированы. Это позволяет избежать ситуации, когда конструкторы взаимно зависят друг от друга.

* Рефакторинг приложения для избегания циклических зависимостей: Это долгосрочное решение, которое включает в себя
  пересмотр и изменение архитектуры приложения, чтобы устранить циклические зависимости. Это может включать в себя
  перераспределение ответственности между бинами или использование паттернов проектирования, таких как Dependency
  Inversion Principle.

Остальные варианты:

* Использование аннотации @CircularDependency: В Spring Framework не существует такой аннотации. Проблема закольцованных
  зависимостей требует решения на уровне конфигурации или архитектуры, а не через аннотации.

* Изменение порядка объявления бинов в конфигурационном файле: Изменение порядка объявления бинов в конфигурационном
  файле
  не решает проблему закольцованных зависимостей, так как это не влияет на взаимные зависимости между бинами. Spring
  Framework сам управляет порядком создания бинов, и правильное решение проблемы требует изменения способов внедрения
  зависимостей или рефакторинга кода.

Использование методов вместо конструкторов и рефакторинг приложения — это два наиболее практичных подхода для решения
проблем закольцованных зависимостей в Spring

# Что представляет собой Feign Client в Spring Cloud и какие основные настройки доступны для его конфигурации?

Feign Client — это библиотека для взаимодействия с RESTful API в микросервисных системах, обеспечивающая декларативный
подход к созданию HTTP-клиентов.

Feign Client упрощает создание HTTP-клиентов, позволяя разработчикам описывать REST API с помощью интерфейсов Java и
аннотаций, таких как @FeignClient. Этот подход избавляет от необходимости писать много кода для обработки HTTP-запросов
и ответов.

Основные настройки для конфигурации Feign Client включают:

1. Базовый URL:

```java

@FeignClient(name = "my-service", url = "http://localhost:8080")
public interface MyServiceClient {
    @GetMapping("/endpoint")
    String getData();
}
```

2. Имя клиента: В аннотации @FeignClient можно указать имя клиента, которое может использоваться для обнаружения
   сервиса (например, через Eureka):

```java

@FeignClient(name = "my-service")
public interface MyServiceClient {
    // методы
}
```

3. Конфигурация тайм-аутов: Настройки тайм-аутов можно задать через конфигурацию Feign, например, в файле
   application.yml:

```yaml
feign:
  client:
    config:
      default:
        connectTimeout: 5000
        readTimeout: 10000
```

4. Кодировка и декодирование данных: Можно настроить использование кастомных кодировщиков и декодировщиков:

```java

@FeignClient(name = "my-service", configuration = MyFeignConfiguration.class)
public interface MyServiceClient {
    // методы
}

@Configuration
public class MyFeignConfiguration {
    @Bean
    public Encoder feignEncoder() {
        return new JacksonEncoder();
    }

    @Bean
    public Decoder feignDecoder() {
        return new JacksonDecoder();
    }
}
```

5. Логирование: Можно настроить уровень логирования для Feign клиента:

```yaml
logging:
  level:
    feign:
      client:
        FeignClient: DEBUG
```

6. Ограничение запросов: С помощью RequestInterceptor можно добавить заголовки или модифицировать запросы:

```java

@Component
public class MyRequestInterceptor implements RequestInterceptor {
    @Override
    public void apply(RequestTemplate template) {
        template.header("Authorization", "Bearer my-token");
    }
}
```

Эти настройки позволяют гибко настраивать работу Feign Client в зависимости от потребностей приложения

## Что представляет собой Testcontainers и как он используется в приложениях Spring?

Testcontainers — это библиотека тестирования, которая позволяет писать тесты с использованием реальных зависимостей с
помощью одноразовых контейнеров Docker. Она предоставляет программируемый API для создания необходимых зависимых
сервисов в виде контейнеров Docker, чтобы вы могли писать тесты, используя реальные сервисы вместо макетов. Таким
образом, независимо от того, пишете ли вы модульные тесты, тесты API или сквозные тесты, вы можете писать тесты с
использованием реальных зависимостей с помощью одной и той же модели программирования.

* <https://habr.com/ru/articles/700286/>

## Что такое контекст Spring и как его создать?

Контекст (а у него есть даже интерфейс — org.springframework.context.ApplicationContext) — это некоторое окружение, в
котором работает приложение на Spring Framework.

Страшные аббревиатуры DI, IoC — это всё про него. Собственно, контекст создаёт и хранит экземпляры классов вашего
приложения, определяет их зависимости друг с другом и автоматически их задаёт.

Безусловно, для того чтобы Spring создал контекст с экземплярами классов, ему нужно предоставить дополнительную
информацию — мета-данные, из каких классов/объектов состоит ваше приложение, как они создаются, какие у них есть
зависимости и т. д.

Итого: Spring Context + мета-данные = работающее приложение.

Где найти контекст?
Контекст является ключевой функциональностью Spring и лежит в maven-зависимости spring-context (на момент написания —
org.springframework:spring-context:5.1.4.RELEASE). Обычно эта зависимость является транзитивной для остальных проектов
Spring. И если вы, например, подключаете spring-boot-starter, то она подключится автоматически, и не нужно думать про
то, где её взять.

Но если вы хотите попробовать "голый" Spring, т. е. только ту часть, которая называется IoC-контейнер, то достаточно
подключить лишь spring-context.

Итого: подключите org.springframework:spring-context:5.1.4.RELEASE.

Какие бывают контексты и как их создать?
У интерфейса ApplicationContext есть большое количество реализаций:

* ClassPathXmlApplicationContext;
* FileSystemXmlApplicationContext;
* GenericGroovyApplicationContext;
* AnnotationConfigApplicationContext;
* и даже StaticApplicationContext;
* а также некоторые другие.

Они отличаются друг от друга именно тем, каким способом задаются мета-данные и где хранится эта конфигурация. Например:

— ClassPathXmlApplicationContext — метаданные конфигурируются XML-файлом(-ами) и они лежат в classpath, т. е. в ресурсах
модуля;

— FileSystemXmlApplicationContext — метаданные тоже конфигурируются XML-файлом(-ами), но они находятся где-то в файловой
системе, например, /etc/yourapp/spring-context.xml;

— AnnotationConfigApplicationContext — метаданные конфигурируются с помощью аннотаций прямо на классах.

ClassPathXmlApplicationContext будет читать файлы из вашего classpath. Они должны быть в classesпапке вашего
веб-приложения или в jarвашей libпапке.

FileSystemXmlApplicationContext может получить доступ ко всей вашей файловой системе, например c:
/config/applicationContext.xml.

XmlWebApplicationContext конечно, может получить доступ к файлам, содержащимся в вашем веб-приложении, но это не самое
главное. Он реализует WebApplicationContext , а это означает, что он будет обнаруживать бины ServletContextAware ,
регистрировать пользовательские области (запрос, сеанс, ...) среди прочего
Современным способом конфигурирования считаются аннотации (AnnotationConfigApplicationContext), дальше будем создавать
именно их.

Приведём пример создания такого контекста в методе main:

    @Configuration
    @ComponentScan
    public class Main {

        public static void main(String[] args) {
            AnnotationConfigApplicationContext context =
                    new AnnotationConfigApplicationContext(Main.class);
        }
    }

Внутри конструктора как раз и происходит инициализация контекста из мета-данных.
Как и полагается, в AnnotationConfigApplicationContext мета-данные конфигурируются аннотациями. Несложно заметить
аннотацию @Configuration на Main-классе, и что он передаётся в конструктор контекста. Собственно, Main и есть описание
метаданных.

Итого: создаём контекст.

В результате мы получили работающее приложение на Spring. Правда, пока ещё без бизнес-логики. А что же означает
аннотация @ComponentScan, и как правильно определять и писать бины, мы узнаем в следующей части.

# Какие scope бинов существуют

В Spring Framework существует несколько областей видимости (scopes) для бинов, каждая из которых определяет жизненный
цикл и видимость бина в контексте приложения. Вот основные из них:

1. Singleton: Это область видимости по умолчанию. Бин с данной областью видимости создается один раз на каждый контейнер
   Spring IoC и кэшируется для последующих запросов. Все запросы на получение бина возвращают один и тот же экземпляр
   бина.

2. Prototype: Бин с данной областью видимости создается заново каждый раз, когда он запрашивается из контейнера. Это
   полезно, когда необходимы разные экземпляры бина для разных задач.

3. Request: Эта область видимости используется в веб-приложениях. Бин создается для каждого HTTP-запроса и уничтожается
   после обработки запроса. Бины с данной областью видимости доступны только в контексте одного HTTP-запроса.

4. Session: Бин с данной областью видимости создается для каждой пользовательской сессии. Бин живет в течение всей
   сессии и уничтожается, когда сессия завершается. Это полезно для хранения информации, специфичной для пользователя, в
   течение всего времени его сессии.

5. Global-session

6. Application: Бин с данной областью видимости создается один раз для всего сервлет-контекста. Это полезно для данных,
   которые должны быть общими для всех пользователей и сессий в приложении.

7. WebSocket: Бин с данной областью видимости создается для каждой сессии WebSocket. Это полезно для работы с данными,
   специфичными для каждой WebSocket-сессии.

Области Request, Session,Global-Session Application и WebSocket доступны только при использовании веб-реализации Spring
ApplicationContext (такой как XmlWebApplicationContext). Являются частью пакета org.springframework.web.
Если вы используете эти области с обычными контейнерами Spring
IoC, такими как ClassPathXmlApplicationContext, генерируется исключение IllegalStateException, которое жалуется на
неизвестную область действия компонента.

# Кладется ли prototype в контейнер

Нет, в контейнере только синглтоны. Это важно, ведь если мы пропишем дестрой методы. При закрытии контекста спринг
пробежится по всем синглтонам их вызовет,
а у prototype они работать не будут

# Потокобезопасен ли singleton?

* Нет, Spring Singelton Bean не является потокобезопасным. Вот пример

```java
public class Emmloyee {
    private int id;
    private String name;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

И вот applicationContext.xml

```xml

<bean id="emp" class="com.manikant.Emmloyee" p:id="26" p:name="Manikant Gautam"/>
```

А вот тестовый класс

```java

public class Test {

    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("com/manikant/config.xml");
        Emmloyee emp = (Emmloyee) ctx.getBean("emp");
        System.out.println("User " + emp.getName() + " is of age " + emp.getId());
        emp.setName("Changed value");

        Emmloyee emp1 = (Emmloyee) ctx.getBean("emp");
        System.out.println("User " + emp1.getName() + " is of age " + emp1.getId());
        //Вот вывод
        //User Manikant Gautam is of age 26
        //User Changed value is of age 26
    }
}

```

Изменение также value отражается emp.setName("Changed value") на разных bean emp1.

# Потокобезопасный Singletone

Создание потокобезопасного синглтона в Java можно осуществить с использованием различных подходов. Вот несколько
способов:

Используя synchronized метод getInstance():

```java
public class ThreadSafeSingleton {
    private static ThreadSafeSingleton instance;

    private ThreadSafeSingleton() {
        // Приватный конструктор 
    }

    public static synchronized ThreadSafeSingleton getInstance() {
        if (instance == null) {
            instance = new ThreadSafeSingleton();
        }
        return instance;
    }
}
}
```

В этом примере метод getInstance() объявлен как synchronized, что гарантирует, что только один поток может выполнить его
одновременно. Однако, этот подход может вызывать некоторые накладные расходы на производительность из-за блокировки
всего метода при каждом доступе к синглтону.

Используя synchronized блок внутри метода getInstance():

```java
public class ThreadSafeSingleton {
    private static ThreadSafeSingleton instance;

    private ThreadSafeSingleton() {
        // Приватный конструктор 
    }

    public static ThreadSafeSingleton getInstance() {
        if (instance == null) {
            synchronized (ThreadSafeSingleton.class) {
                if (instance == null) {
                    instance = new ThreadSafeSingleton();
                }
            }
        }
        return instance;
    }
}
}
```

В этом подходе используется double checked locking, который обеспечивает ленивую инициализацию синглтона без
синхронизации при каждом доступе. Однако, реализация double checked locking может быть сложной и подвержена ошибкам.

Используя статический вложенный класс (static nested class):

```java
public class ThreadSafeSingleton {
    private ThreadSafeSingleton() {
        // Приватный конструктор 
    }

    private static class SingletonHelper {
        private static final ThreadSafeSingleton instance = new ThreadSafeSingleton();
    }

    public static ThreadSafeSingleton getInstance() {
        return SingletonHelper.instance;
    }
}

```

В этом подходе экземпляр синглтона создается при загрузке класса SingletonHelper, что гарантирует потокобезопасность.
Это основано на механизме инициализации статических полей в Java.

Используя перечисление (enum):

```java
public enum ThreadSafeSingleton {
    INSTANCE;

    // Дополнительные поля и методы
    public void doSomething() {
        // Реализация }
    }
}
```

В этом подходе синглтон создается автоматически при загрузке перечисления и гарантируется его уникальность и
потокобезопасность.

Выбор конкретного подхода зависит от требований и контекста вашего приложения. Важно помнить, что потокобезопасность
синглтона - это только один из аспектов, которые следует учитывать при разработке.

# BeanDefinitions что эт такое и что первее создаеться bean или beanDefinitions

BeanDefinition — это специальный интерфейс, через который можно получить доступ к метаданным будущего бина. В
зависимости от того, какая у вас конфигурация, будет использоваться тот или иной механизм парсирования конфигурации (
xml, groove, аннотации и тд).
> <https://habr.com/ru/articles/222579/>    