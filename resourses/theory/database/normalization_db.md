### Нормальзация, формы

![Normalization_example.png](../../picture/normaliztionbd/Normalization_example.png)
В первой строке последнего столбца цена указана в долларах, в остальных записях — это рубли. Последняя запись повторяет
предыдущую, потому что этот заказ выполнил тот же человек, но сделал это в другое время.

В этой табличке много повторяющейся информации. Приведем ее к правильной структуре с точки зрения реляционной модели.
Для этого приведем данные к нормальной форме — это требования, которые минимизируют избыточность данных, потенциально
приводящих к логическим ошибкам.

Всего существует шесть нормальных форм, которые включают определенные требования. С каждым следующим уровнем требования
все жестче, так как включают в себя предыдущие уровни.

В рамках курса мы разберем три нормальные формы. В этом уроке познакомимся с первой.

#### 1 Нормальная форма

Первая нормальная форма сводится к трем правилам:

- Каждая ячейка таблицы может хранить только одно значение (Отсутствуют массивы и списки в любом виде)
- Все данные в одной колонке могут быть только одного типа
- Каждая запись в таблице должна однозначно отличаться от других записей

Каждая ячейка – одно значение
Вернемся к примеру выше. У одной записи поля item и price содержат два значения через запятую. У такого способа
организации данных много недостатков. Например, пропадает возможность делать обычную выборку по условиям:

-- Как задать условие, чтобы получить все записи о проданных утюгах?

```SELECT * FROM order_items WHERE item = ...;```

Другая проблема связана с типами данных. Поле price в таблице order_items имеет числовой тип (numeric). Если мы захотим
хранить там более одного значения, то тип превратится в строковый, а все данные станут обычными строками.

При такой организации невозможно проверить корректность данных и формат числа. Становится проблематично выполнить
агрегирующие запросы, например, считать выручку за определенный месяц одним запросом.

Чтобы избавиться от перечислений в ячейках, можно создать новые записи:
![Normalization_example2.png](../../picture/normaliztionbd/Normalization_example2.png)

Теперь на одной строке находится информация только по одному товару. Так мы избавились от перечислений в поле, что
позволит выполнять агрегирующие запросы, а также не будет путаницы с типами данных.

Данные одного типа
Снова вернемся к таблице. Верхняя запись в ней содержит цену в долларах, хотя все остальные цены указаны в рублях.
Технически база никак не укажет на это. И доллары, и рубли представлены числами, но с точки зрения программы у этих
чисел разная природа.

Разные данные в рамках одного поля тоже не дают выполнить агрегирующие запросы, например, поиск сумм, максимального,
минимального. Еще усложняется обработка данных на уровне кода. В коде придется каким-то образом понимать, что из себя
представляют данные.

Вот еще несколько примеров с похожей ситуацией:

Хранение даты свадьбы в поле «день рождения»
Хранение номера телефона вместо адреса в поле «адрес»
Исправленная версия таблицы:
![Normalization_example3.png](../../picture/normaliztionbd/Normalization_example3.png)

Мы сконвертировали цену утюга в первой строке из долларов в рубли. Теперь у данных в поле price один тип. Так программе
будет легче выполнять агрегирующие запросы.

Уникальные записи
Последние две записи в таблице выглядят идентично, хотя это два разных заказа. Их сделал один человек, но в разное
время:
Сергей Иванов Москва, ул. Матросова ноутбук 20000.00
Сергей Иванов Москва, ул. Матросова ноутбук 20000.00
Реляционная модель требует от нас уникальности каждой записи. Иначе нельзя понять, что к чему относится и с какой
записью нужно работать при изменениях. Можно начать править не то и потерять важную информацию. При этом мы не можем
полагаться на порядок данных внутри таблицы, так как он не гарантирован.

Реализовать уникальность можно несколькими способами, например, добавить новое поле с датой заказа, которое сделает
запись уникальной. Этот способ не очень надежный и не очень удобный в работе. Придется постоянно анализировать весь
набор полей.

Лучше добавить первичный ключ (PRIMARY KEY) — поле или набор полей, которые содержат уникальное значение для каждой
записи. Первичный ключ не может меняться, его значение однозначно определяет любую запись в таблице.

Разберем два вида первичного ключа:

Естественный — когда используются значения из окружающего мира, например, email, ФИО или паспортные данные. При этом
нужно убедиться, что ключ не будет повторяться. Такие первичные ключи используют редко из-за их ненадежности. Часто они
не уникальны и могут изменяться или повторяться. Например, номер паспорта меняется при смене документа
Суррогатный — когда используются автоматически генерируемые уникальные значения. Такой ключ поддерживается любой базой
данных «из коробки». Иногда это просто числа, а иногда — сложные число-буквенные строки или хеши
Добавим в нашу таблицу первичный ключ:
![Normalization_example4.png](../../picture/normaliztionbd/Normalization_example4.png)

Первичный ключ принято создавать первым полем с названием id. Для первичного ключа обязательно указывать PRIMARY KEY в
описании таблицы:

``` 
-- Первичный ключ только один на таблицу 
        CREATE TABLE products   
        ( id bigint PRIMARY KEY, first_name varchar(255), last_name varchar(255), address varchar(255), item varchar(255),  
        price numeric -- специальный тип данных, который подходит под работу с деньгами. 
        Обеспечивает высокую точность при расчетах. )
```

Такой ключ все еще нужно формировать самостоятельно, но теперь база данных сама следит за уникальностью. При попытке
создать запись с повторяющимися первичными ключами возникнет ошибка.

#### 2 Нормальная форма

Вторая нормальная форма включает в себя два требования:

1) должна быть в первой нормальной форме
2) Все неключевые атрибуты таблицы должны зависеть от первичного ключа

Это называется полная функциональная зависимость. Первичный ключ может быть составным. Но 2 форма предусматривает
что все неключевые атрибуты должны зависеть от первичного ключа всего
Иначе Частичной зависимостью (частичной функциональной зависимостью) называется зависимость неключевого атрибута от
части составного ключа (первичного).

Первое требование уже выполнено, так как в таблице:

- Каждая ячейка хранит только одно значение
- Все данные в одной колонке одного типа
- Каждая запись отличается от других записей

Поэтому разберем подробнее второе требование.

Зависимость от первичного ключа
Зависимость атрибута от первичного ключа — это ситуация, при которой ключ имеет значение, зависимое от конкретного
контекста. Предположим, что в таблице, Сергей — это всегда один и тот же человек, который делает заказ на разные адреса.
В таком случае видно, что заказ привязан к конкретному пользователю. Это и есть зависимость от первичного ключа. А вот
имя пользователя и его фамилия с заказом никак не связано. Оно имеет отношение к самому пользователю.

Согласно второй форме, атрибуты first_name и last_name необходимо вынести в свою таблицу, которая будет отвечать за
пользователей:

#### Зависимость от первичного ключа

Зависимость атрибута от первичного ключа — это ситуация, при которой ключ имеет значение, зависимое от конкретного
контекста. Предположим, что в таблице, Сергей — это всегда один и тот же человек, который делает заказ на разные адреса.
В таком случае видно, что заказ привязан к конкретному пользователю. Это и есть зависимость от первичного ключа. А вот
имя пользователя и его фамилия с заказом никак не связано. Оно имеет отношение к самому пользователю.

Согласно второй форме, атрибуты first_name и last_name необходимо вынести в свою таблицу, которая будет отвечать за
пользователей:
![Normalization_example5.png](../../picture/normaliztionbd/Normalization_example5.png)

В этой таблице всего три записи, потому что у нас три уникальных пользователя. Каждому из этих пользователей
присваивается первичный ключ.

Теперь нужно связать таблицу order_items с таблицей users. Делается это через указание первичных ключей в зависимых
таблицах:
![Normalization_example6.png](../../picture/normaliztionbd/Normalization_example6.png)

Мы удалили first_name, last_name и добавили user_id. В этом поле хранятся идентификаторы пользователей, а само поле
называется внешним или вторичным ключом.

Такую же операцию нужно произвести и с товаром. Вынесем item в свою таблицу:
![goods.png](../../picture/normaliztionbd/goods.png)
Теперь свяжем эти данные с таблицей order_items:
![Normalization_example7.png](../../picture/normaliztionbd/Normalization_example7.png)

Внешний ключ — это не ссылка. Таблицы существуют сами по себе, и во внешнем ключе указывается конкретное значение,
которое должно совпадать с первичным ключом другой таблицы.

Так выглядит синтаксис определения вторичного ключа:

REFERENCES <название таблицы, на которую смотрим> (<список полей в той таблице, которым соответствуем>)

```
-- Внешних ключей может быть любое количество: сколько ссылок — столько и ключей
CREATE TABLE orders (
id bigint PRIMARY KEY,
-- Тип внешнего ключа должен быть такой же,
-- как у первичного в той таблице, куда ссылается внешний
user_id bigint REFERENCES users (id),
-- остальные поля
);
```

Благодаря вторичному ключу поддерживаются гарантии корректности данных. Например, невозможно удалить запись из основной
таблицы, если на нее есть ссылки из внешних ключей в другой таблице. Так не получится случайно завести базу в
неконсистентное состояние — когда данные ссылаются на несуществующие данные.

### 2 пример

Во второй нормальной форме каждый столбец в таблице, который не является ключом, должен зависеть от ключа.

Ключевой момент второй нормальной формы - полная функциональная зависимость. Она предполагает, что атрибут В полностью
функционально зависим от атрибута А, если атрибут В функционально зависит от полного значения атрибута А, а не от
какого-либо подмножества значений из атрибута А. То есть, если атрибут А составляют несколько значений, скажем, А1 и А2,
то атрибут В полностью функционально зависит от А, если он зависит и от А1 и от А2 (А1, А2 → В).

Если атрибут В зависит только от какого-либо подмножества из атрибута А, например, только от А1, то имеет место
частичная функциональная зависимость.

Эта форма применяется к тем таблицам, которые имеют составной первичный ключ, то есть где первичный ключ состоит из
нескольких атрибутов. Если в таблице несоставной первичный ключ, то в этом случае считается, что все остальные атрибуты
автоматически находятся в полной функциональной зависимости от первичного ключа.

Вторая нормальная форма применяется только к тем таблицам, которые находятся в первой нормальной форме. После применения
второй формы все столбцы таблицы зависят от первичного ключа.

Возьмем сформированную в прошлой теме таблицу StudentCourses после применения первой нормальной формы:

| StudentId | Name | CourseId | Course     | Date        | TeacherId | Teacher |
|-----------|------|----------|------------|-------------|-----------|---------|
| 1         | 	Том | 	1       | Математика | 	11/06/2017 | 	1        | 	Смит   |
| 1         | 	Том | 	2       | JavaScript | 	14/06/2017 | 	2        | 	Адамс  |
| 2         | 	Сэм | 	3       | Алгоритмы  | 	12/06/2017 | 	2        | 	Адамс  |
| 3         | Боб  | 1        | Математика | 13/06/2017  | 1         | Смит    |

На данный момент эта таблица имеет составной первичный ключ StudentId+CourseId. Какие функциональные зависимости от
ключевых атрибутов здесь можно выделить:

StudentId, CourseId → Date

StudentId → Name

CourseId → Course, TeacherId, Teacher

От обоих частей составного ключа StudentId+CourseId зависит только арибут Date - дата, в которую студент с
идентификатором StudentId поступил на курс с идентифкатором CourseId.

Атрибут Name зависит только от части составного ключа - от атрибута StudentId, так как зная идентификатор студента,
можно сказать, какое у него имя. В данном случае имеет факт частичной зависимости.

Атрибуты Course, TeacherId, Teacher, Position зависит от другой части ключа - от атрибута CourseId. Зная значение
CourseId, можно сказать, как называется курс, какой у курса преподаватель, какую должность он занимает. Опять же здесь
частичная зависимость.

Наличие частичных зависимостей говорит о том, что таблица не находится во второй нормальной форме. И для перехода к этой
форме необходимо переместить атрибуты, которые не входят в первичный ключ, в новую таблицу вместе с копией части
первичного ключа, от которой они функционально зависят.

В нашем случае из одной таблицы получатся три. Таблица Students:

| StudentId | Name |
|-----------|------|
| 1         | Том  |
| 2         | Сэм  |
| 3         | Боб  |

Таблица Courses:

| CourseId | Course     | TeacherId | Teacher |
|----------|------------|-----------|---------|
| 1        | Математика | 1         | Смит    |
| 2        | JavaScript | 2         | Адамс   |
| 3        | Алгоритмы  | 2         | Адамс   |

И таблица StudentCourses:

| StudentId | CourseId | Date       |
|-----------|----------|------------|
| 1         | 1        | 11/06/2017 |
| 1         | 2        | 14/06/2017 |
| 2         | 3        | 12/06/2017 |
| 3         | 1        | 13/06/2017 |

Итогом стало образование связи многие ко многим (много студентов - много курсов) между таблицами Students и Courses
через таблицу StudentCourses .

Таким образом, база данных перешла во вторую нормальную форму.

## Ссылки

<https://ru.hexlet.io/courses/rdb-basics/lessons/1nf/theory_unit>
<https://ru.hexlet.io/courses/rdb-basics/lessons/2nf/theory_unit>