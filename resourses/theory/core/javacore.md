# Что такое класс Object и почему все его наследуют

Так как у нас объектно-ориентированный язык программирования, то нам нужны методы и характеристики объектов.
В ООП есть наследование, поэтому методы описывающие класс object необходимы в любом классе который мы проектируем (
toString, equals, hashcode).
Мы должны уметь их отличать.
Помимо этого это свойство полиморфизма, когда переменной Object obj= new A() мы можем присвоить любой класс.
Там где переменная или дженерик класс предка - мы можем использовать любого его потомка.

Класс `Object` обеспечивает общие методы, которые могут быть использованы или переопределены любым классом для
выполнения таких задач, как сравнение объектов, их клонирование, возвращение строкового представления объекта, и
управление потоками

# Можно ли создать интерфейс класса Object. И для чего это может потребоваться

Да, так как он не является интерфейсом или абстрактным классом.
Нужен этот объект например - для многопоточности. Каждый объект может быть использован в качестве монитора
многопоточности.
Это нужно для синхронизации доступа.

```java
public class Test {
    final Object LOCK = new Object();

    public void method() {
        synchronized (LOCK) {
            System.out.println("run this method");
        }
    }
}
```

## Методы класса Object

* public String toString()
  Возвращает строковое представление объекта.

* public native int hashCode()
* public boolean equals(Object obj)
  Пара методов, которые используются для сравнения объектов.

* public final native Class getClass()
  Возвращает специальный объект, который описывает текущий класс.

* public final native void notify()
* public final native void notifyAll()
* public final native void wait(long timeout)
* public final void wait(long timeout, intnanos)
* public final void wait()
  Методы для контроля доступа к объекту из различных нитей. Управление синхронизацией нитей.
  Они работают только с synchronized блоками и методами. Иначе если вызвать то получим IllegalMonitorStateException

```java
public class WaitExample {
    public static void main(String[] args) {
        Object obj = new Object();
        try {
            obj.wait();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
//Exception in thread "main" java.lang.IllegalMonitorStateExceptio
```

* protected void finalize()
  Метод позволяет «освободить» родные не-Java ресурсы: закрыть файлы, потоки и т.д.
  метод вызывается перед сборкой мусора
  С 9 версии он @Deprecated. Расчитывать на то что этот метод вызовется перед сборкой мусора не нужно. Потому что не
  известно когда сработает сборщик мусора

* protected native Object clone()
  Метод позволяет клонировать объект: создает дубликат объекта

# Что такое hashCode. Какая у него реализация?

Отображение объекта в 32 битное число.
Дефолтная реализация написана на С++, об этом нам говорит сигнатура метода native int hashCode();
Когда мы прописываем для класса, нам нужно сформировать алгоритм с учетом всех полей объекта.
Например так

```java

@Override
public int hashCode() {
    int result = Objects.hashCode(propertyOne);
    result = 31 * result + propertyTwo;
    return result;
}
```

# Какой контракт  hashCode

1. Повторный вызов hashCode для одного и того же объекта должен возвращать одинаковые хеш-значения, если поля объекта,
   участвующие в вычислении значения, не менялись.
2. Если equals() для двух объектов возвращает true, hashCode() также должен возвращать для них одно и то же число.
3. При этом неравные между собой объекты могут иметь одинаковый hashCode.

# Контракт equals() в Java

Каких правил к использованию equals, мы должны придерживаться , определённых в спецификации Java:

1. Рефлексивность — x.equals(x) возвращает true.
2. Симметричность — x.equals(y) <=> y.equals(x).
3. Транзитивность — x.equals(y) <=> y.equals(z) <=> x.equals(z).
4. Согласованность — повторный вызов x.equals(y) должен возвращать значение предыдущего вызова, если сравниваемые поля
   не изменялись.
5. Сравнение null — x.equals(null) возвращает false.

# Что будет если предопределить equals а hashcode нет.

Если предопределить только equals - у нас сломается логика использования hashmap или hashset. Equals и hashcode
работают вместе чтобы функционировала коллекция. Если не будет работать equals, то в коллекции найдется по hashcode
корзина,а элемент по equals не найдется. Если наоборот, то по hashcode не найдется корзина и до equals не дойдет дело.  
Так же если вдруг поменяется hashcode налету - то в коллекции попросту не найдет корзину.

Поэтому ключом hashmap выбирают неизменяемые классы такие как String, чтобы нельзя было поменять hashcode

# Статическое связывание

Что выведет эта программа? Collection, Set или HashSet?

```java
public class Example {
    public static void main(String[] args) {
        Collection collection = new HashSet();
        print(collection);
    }

    private static void print(Collection collection) {
        System.out.println("collection");
    }

    private static void print(Set collection) {
        System.out.println("set");
    }

    private static void print(HashSet collection) {
        System.out.println("hashSet");
    }
}
```

Приватные, статические и final-методы связываются
при помощи статического связывания (Раннего), а виртуальные – динамического. Аналогично, лучший пример статического
связывания –
перегрузка методов, а переопределение – динамического.

# Что такое функциональный интерфейс?

Функциональный интерфейс также известен как интерфейс единого абстрактного метода (Single Abstract Method, SAM). Как
следует из названия, он может иметь не более одного абстрактного метода.

Функциональный интерфейс может иметь несколько статических методов и методов по умолчанию с реализацией, а также
дополнительный абстрактный метод. Чтобы пометить интерфейс как функциональный, используется аннотация
@FunctionalInterface. Она нужна, чтобы избежать ошибочного объявления дополнительных методов.

Что делает функциональный интерфейс таким популярным, так это возможность использования лямбда-выражений для создания
интерфейсов без использования анонимных и громоздких реализаций классов.

Использование ключевого слова abstract в функциональных интерфейсах необязательно, поскольку методы, определенные внутри
интерфейса, по умолчанию являются абстрактными.

# Какие виды вложенных классов существуют

1) Вложенные внутренние классы – нестатические классы внутри внешнего класса.
2) Вложенные статические классы – статические классы внутри внешнего класса.
3) Локальные классы Java – классы внутри методов.
4) Анонимные Java классы – классы, которые создаются на ходу.

#### Вложенные внутренние классы – нестатические классы внутри внешнего класса.

``` java
  public class Airplane {
      private String name, id, flight;
      private Wing leftWing = new Wing("Red", "X3"), rightWing = new Wing("Blue", "X3");
  
      public Airplane(String name, String id, String flight) {
          this.name = name;
          this.id = id;
          this.flight = flight;
      }
  
      private class Wing {
          private String color, model;
  
          private Wing(String color, String model) {
              this.color = color;
              this.model = model;
          }
  
          // getters/setters
      }
  
      // getters/setters
  }
 ```

##### Особенности нестатических вложенных классов Java:

* Они существуют только у объектов, потому для их создания нужен объект. Другими словами: мы укомплектовали наше крыло
  так, чтобы оно было частью самолета, потому, чтобы создать крыло, нам нужен самолет, иначе оно нам не нужно.
* Внутри Java класса не может быть статических переменных. Если вам нужны какие-то константы или что-либо еще
  статическое, выносить их нужно во внешний класс. Это связано с тесной связью нестатического вложенного класса с
  внешним классом.
* У класса полный доступ ко всем приватным полям внешнего класса. Данная особенность работает в две стороны.
* Можно получить ссылку на экземпляр внешнего класса. Пример: Airplane.this – ссылка на самолет, this – ссылка на крыло.

#### Вложенные статические классы – статические классы внутри внешнего класса.

Данный вид классов не отличается ничем от обычного внешнего класса, кроме одного: для создания экземпляра такого класса,
нужно через точку перечислить весь путь от внешнего класса до нужного. Например: Building.Plaftorm platform = new
Building.Platform();

Статические классы используются для того, чтобы укомплектовать связанные классы рядышком, чтобы с логической структурой
было работать проще. Например: мы можем создать внешний класс Building, где будет конкретный список классов, которые
будут представлять из себя уже конкретную постройку.

```java

public abstract class Building {
    private String name, address, type;

    Building(String name, String address) {
        this.name = name;
        this.address = address;
    }

    public static class Platform extends Building {
        public Platform(String name, String address) {
            super(name, address);
            setType("Platform");
        }

        // some additional logic
    }

    public static class House extends Building {
        public House(String name, String address) {
            super(name, address);
            setType("House");
        }

        // some additional logic
    }

    public static class Shop extends Building {
        public Shop(String name, String address) {
            super(name, address);
            setType("Shop");
        }

        // some additional logic
    }

    // getters/setters
}

```

Данный пример демонстрирует, как статические классы позволяют укомплектовывать логическую структуру в более удобный вид.
Если бы их не было, нам бы понадобилось создавать 4 совершенно разных класса.

#### Плюсы такого подхода:

* Количество классов уменьшилось.
* Все классы внутри их класса-родителя. Мы способны прослеживать всю иерархию без открытия каждого класса отдельно.
* Мы можем обратиться к классу Building, а IDE уже будет подсказывать весь список всех подклассов данного класса. Это
  будет упрощать поиск нужных классов и показывать всю картину более цело.
* Пример создания экземпляра вложенного статического класса:
  ``` Building.Shop myShop = new Building.Shop(“Food & Fun!”, “Kalyaeva 8/53”);```

#### Локальные классы Java – классы внутри методов.

Локальные классы способны работать только с final переменными метода. Все дело в том, что экземпляры локальных классов
способны сохраняться в «куче» после завершения работы метода, а переменная может быть стёрта. Если же переменная
объявлена final, то компилятор может сохранить копию переменной для дальнейшего использования объектом. И еще: с 8+
версий Java можно использовать не final переменные в локальных классах, но только при условии, что они не будут
изменяться.
Локальные классы нельзя объявлять с модификаторами доступа.
Локальные классы обладают доступом к переменным метода.
Локальные классы можно встретить крайне редко, так как они затрудняют прочтение кода и не обладают никакими плюсами,
кроме одного – доступ к переменным метода. Я не знаю, какой можно взять пример локального класса, который бы показал их
эффективное применение, так что покажу просто свой пример.

Допустим, что у нас есть класс Person (будет считать, что это человек) со свойствами street (улица), house (дом). Нам бы
хотелось возвращать какой-то объект для доступа только к местоположению человека. Для этого, мы создали интерфейс
AddressContainer, который подразумевает собой хранилище данных об местоположении человека.

```java
public class Person {
    private String name, street, house;

    public Person(String name, String street, String house) {
        this.name = name;
        this.street = street;
        this.house = house;
    }

    private interface AddressContainer {
        String getStreet();

        String getHouse();
    }

    public AddressContainer getAddressContainer() {
        class PersonAddressContainer implements AddressContainer {
            final String street = Person.this.street, house = Person.this.house;

            @Override
            public String getStreet() {
                return this.street;
            }

            @Override
            public String getHouse() {
                return this.house;
            }
        }
        return new PersonAddressContainer();
    }

    public static void main(String[] args) {
        Person person = new Person("Nikita", "Sholohova", "17");
        AddressContainer address = person.getAddressContainer();
        System.out.println("Address: street - " + address.getStreet() + ", house - " + address.getHouse());
    }

    // getters/setters
}
```

Как можно заметить, внутри метода мы создали класс, реализующий хранилище местоположения человека, создали там
константные переменные (чтобы после выхода из метода переменные хранились в объекте) и реализовали метод для получения
адреса и дома. Теперь мы можем использовать данный объект в других местах программы, чтобы получать местоположение
человека.

#### Анонимные Java классы – классы, которые создаются на ходу.

Под капотом анонимные классы – просто обычные нестатические вложенные классы. Их особенность в удобстве их
использования. Вы можете написать свой класс прямо при создании экземпляра другого класса.

```java
public class Animal {
    public void voice() {
        System.out.println("Meow!");
    }

    public static void main(String[] args) {
        Animal doggy = new Animal() {
            @Override
            public void voice() {
                System.out.println("Gav!");
            }
        };

        Animal cat = new Animal();
        Animal cow = new Animal().new Cow();

        cat.voice(); // будет выведено Meow!
        cow.voice(); // будет выведено Moooo!
        doggy.voice(); //будет выведено Gav!
    }

    private class Cow extends Animal {
        @Override
        public void voice() {
            System.out.println("Moooo!");
        }
    }
}
```

По сути, мы просто совмещаем в одном месте две вещи: создание экземпляра одного класса (Animal) и создание экземпляра
его внутреннего-класса наследника (Tiger). Иначе нам нужно создавать класс отдельно и использовать более длинные
конструкции, чтобы добиться того же самого результата.

#### Использование анонимных классов оправдано во многих случаях, в частности когда:

* тело класса является очень коротким;
* нужен только один экземпляр класса;
* класс используется в месте его создания или сразу после него;
* имя класса не важно и не облегчает понимание кода.

Часто анонимные классы используются в графических интерфейсах для создания обработчиков событий. Например для создания
кнопки и реакции на её нажатие:

```
JButton b2 = new JButton("Click");
b2.addActionListener(new ActionListener() {
  public void actionPerformed(ActionEvent e) {
    System.out.println("Кнопка нажата!");
  }
});

```

Однако после Java 8 начали использовать лямбда-выражения, но все равно много кода было написано до 8 версии и вы можете
столкнуться (и столкнетесь в ходе обучения на JavaRush) с такими вот надписями.\

Аналог с лямбдами:

```
JButton b2 = new JButton("Click");
b2.addActionListener(e -> System.out.println("Кнопка нажата!"));
```

# Что такое Generic
https://github.com/VasiliyVelikyy/InterviewQuestions/blob/main/resourses/theory/core/generics.md
