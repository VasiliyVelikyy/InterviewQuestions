# Что такое класс Object и почему все его наследуют

Так как у нас объектно-ориентированный язык программирования, то нам нужны методы и характеристики объектов.
В ООП есть наследование, поэтому методы описывающие класс object необходимы в любом классе который мы проектируем (
toString, equals, hashcode).
Мы должны уметь их отличать.
Помимо этого это свойство полиморфизма, когда переменной Object obj= new A() мы можем присвоить любой класс.
Там где переменная или дженерик класс предка - мы можем использовать любого его потомка.

Класс `Object` обеспечивает общие методы, которые могут быть использованы или переопределены любым классом для
выполнения таких задач, как сравнение объектов, их клонирование, возвращение строкового представления объекта, и
управление потоками

# Можно ли создать интерфейс класса Object. И для чего это может потребоваться

Да, так как он не является интерфейсом или абстрактным классом.
Нужен этот объект например - для многопоточности. Каждый объект может быть использован в качестве монитора
многопоточности.
Это нужно для синхронизации доступа.

```java
public class Test {
    final Object LOCK = new Object();

    public void method() {
        synchronized (LOCK) {
            System.out.println("run this method");
        }
    }
}
```

## Методы класса Object

* public String toString()
  Возвращает строковое представление объекта.

* public native int hashCode()
* public boolean equals(Object obj)
  Пара методов, которые используются для сравнения объектов.

* public final native Class getClass()
  Возвращает специальный объект, который описывает текущий класс.

* public final native void notify()
* public final native void notifyAll()
* public final native void wait(long timeout)
* public final void wait(long timeout, intnanos)
* public final void wait()
  Методы для контроля доступа к объекту из различных нитей. Управление синхронизацией нитей.
  Они работают только с synchronized блоками и методами. Иначе если вызвать то получим IllegalMonitorStateException

```java
public class WaitExample {
    public static void main(String[] args) {
        Object obj = new Object();
        try {
            obj.wait();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
}
//Exception in thread "main" java.lang.IllegalMonitorStateExceptio
```

* protected void finalize()
  Метод позволяет «освободить» родные не-Java ресурсы: закрыть файлы, потоки и т.д.
  метод вызывается перед сборкой мусора
  С 9 версии он @Deprecated. Расчитывать на то что этот метод вызовется перед сборкой мусора не нужно. Потому что не
  известно когда сработает сборщик мусора

* protected native Object clone()
  Метод позволяет клонировать объект: создает дубликат объекта

# Что такое hashCode. Какая у него реализация?

Отображение объекта в 32 битное число.
Дефолтная реализация написана на С++, об этом нам говорит сигнатура метода native int hashCode();
Когда мы прописываем для класса, нам нужно сформировать алгоритм с учетом всех полей объекта.
Например так

```java

@Override
public int hashCode() {
    int result = Objects.hashCode(propertyOne);
    result = 31 * result + propertyTwo;
    return result;
}
```

# Какой контракт между hashCode и equals методами. Что будет если предопределить equals а hashcode нет.

Если предопределить только equals - у нас сломается логика использования hashmap или hashset. Equals и hashcode
работают вместе чтобы функционировала коллекция. Если не будет работать equals, то в коллекции найдется по hashcode
корзина,а элемент по equals не найдется. Если наоборот, то по hashcode не найдется корзина и до equals не дойдет дело.  
Так же если вдруг поменяется hashcode налету - то в коллекции попросту не найдет корзину.

Поэтому ключом hashmap выбирают неизменяемые классы такие как String, чтобы нельзя было поменять hashcode

# Статическое связывание

Что выведет эта программа? Collection, Set или HashSet?

```java
public class Example {
    public static void main(String[] args) {
        Collection collection = new HashSet();
        print(collection);
    }

    private static void print(Collection collection) {
        System.out.println("collection");
    }

    private static void print(Set collection) {
        System.out.println("set");
    }

    private static void print(HashSet collection) {
        System.out.println("hashSet");
    }
}
```

Приватные, статические и final-методы связываются
при помощи статического связывания (Раннего), а виртуальные – динамического. Аналогично, лучший пример статического
связывания –
перегрузка методов, а переопределение – динамического.

### Что такое функциональный интерфейс?

Функциональный интерфейс также известен как интерфейс единого абстрактного метода (Single Abstract Method, SAM). Как
следует из названия, он может иметь не более одного абстрактного метода.

Функциональный интерфейс может иметь несколько статических методов и методов по умолчанию с реализацией, а также
дополнительный абстрактный метод. Чтобы пометить интерфейс как функциональный, используется аннотация
@FunctionalInterface. Она нужна, чтобы избежать ошибочного объявления дополнительных методов.

Что делает функциональный интерфейс таким популярным, так это возможность использования лямбда-выражений для создания
интерфейсов без использования анонимных и громоздких реализаций классов.

Использование ключевого слова abstract в функциональных интерфейсах необязательно, поскольку методы, определенные внутри
интерфейса, по умолчанию являются абстрактными.