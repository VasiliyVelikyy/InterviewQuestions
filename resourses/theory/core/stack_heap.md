# Где хранится примитивная переменная класса

```В Java примитивы и ссылки на объекты хранятся в стэке, а объекты в куче```

Это не так. Ссылки и примитивы тоже могут храниться в куче.

Важно понимать разницу между переменной и полем.

```java

class User {
    private int age = 42;
    private String name = "John Doe";

    public void someMethod() {
        int someVar = 2;
        User user = new User();
    }
}

```

age - это поле. Оно имеет примитивный тип, но храниться будет там же, где и объект - в куче. Так же и поле ссылочного
типа name.

someVar и user - это переменные и они хранятся в стеке. В первой хранится значение 2, во втором ссылка на объект класса
User.

В том смысле, что когда завершится функция, которая создавала user - то указатель стэка должен сместиться вниз, и все
эти переменные - ссылка на user, примитив int age и ссылка на name должны исчезнуть из памяти.

При завершении метода someMethod кадр стека будет уничтожен и вместе с ним перестанут существовать переменные someVar и
user. Но сам объект user останется в куче до следующего вызова сборщика мусора. Сборщик мусора при запуске проверит все
существующие кадры стека, не найдёт в них ссылки на объект user и только тогда удалит его.

# Что такое стек в памяти java

Стек есть стек - структура типа LIFO. При вызове метода - создаётся фрейм этого метода и пушиться на верх стека. При
завершении выполнения фрейм с верха стека убирается. Фрейм наверху стека - это текущий фрейм.
Фреймы внутри содержат локальные переменные, параметры метода. Если метод не статический - ещё фрейм хранит неявный
параметр this.
![img.png](media/img4.png)
Возможно, вы заметили, что на картинке выше отображено несколько стеков памяти. Это связано с тем, что стековая память в
Java выделяется для каждого потока. Следовательно, каждый раз, когда поток создается и запускается, он имеет свою
собственную стековую память и не может получить доступ к стековой памяти другого потока.

Фрейм стека - область выполнения в конкретном стеке. Например выполнение метода.
Кроме того, переменные в стеке имеют определенную видимость, также называемую областью видимости. Используются только
объекты из активной области.

## Куча (Heap)

Эта часть памяти хранит в памяти фактические объекты, на которые ссылаются переменные из стека. Например, давайте
проанализируем, что происходит в следующей строке кода:

```StringBuilder builder = new StringBuilder();```
Ключевое слово new несет ответственность за обеспечение того, достаточно ли свободного места на куче, создавая объект
типа StringBuilder в памяти и обращаясь к нему через «builder» ссылки, которая попадает в стек.

Для каждого запущенного процесса JVM существует только одна область памяти в куче. Следовательно, это общая часть памяти
независимо от того, сколько потоков выполняется. На самом деле структура кучи немного отличается от того, что показано
на картинке выше. Сама куча разделена на несколько частей, что облегчает процесс сборки мусора.

Максимальные размеры стека и кучи не определены заранее - это зависит от работающей JVM машины. Позже в этой статье мы
рассмотрим некоторые конфигурации JVM, которые позволят нам явно указать их размер для запускаемого приложения.

# По ссылке или по значению передаются переменные в java

### 1 пример

Java всегда передает параметры по значению.

В программировании существуют два основных способа передачи данных между функциями или методами: передача по значению и
передача по ссылке.

Передача по значению означает, что когда мы передаем переменную в функцию, фактически передается копия значения этой
переменной. Это означает, что изменения, которые происходят с переменной внутри функции, не влияют на исходное значение.

```java
void updateValue(int value) {
    value = 50;
}

public static void main(String[] args) {
    int value = 30;
    updateValue(value);
    System.out.println(value);  // Выводит: 30
}
```

Передача по ссылке, наоборот, означает, что передается ссылка на переменную, а не ее значение. Изменения, которые
происходят с переменной внутри функции, влияют на исходное значение.

```java
void updateValue(int[] value) {
    value[0] = 50;
}

public static void main(String[] args) {
    int[] value = {30};
    updateValue(value);
    System.out.println(value[0]);  // Выводит: 50
}
```

Java и передача параметров
Теперь, когда мы разобрались с основами, давайте обратимся к Java. Несмотря на то, что при работе с объектами в Java
используются ссылки, сам язык все равно использует передачу по значению.
Когда мы передаем объект в метод, Java передает значение ссылки на этот объект, а не саму ссылку. Это означает, что
метод работает с копией ссылки, а не с оригинальной ссылкой. Изменения, которые происходят с объектом, влияют на
исходный объект, потому что копия ссылки все равно указывает на тот же объект. Однако если мы попытаемся изменить саму
ссылку (например, присвоить ей новый объект), эти изменения не будут видны за пределами метода.

```java
void updateObject(Foo foo) {
    foo.setValue(50);
    foo = new Foo(100);
}

public static void main(String[] args) {
    Foo foo = new Foo(30);
    updateObject(foo);
    System.out.println(foo.getValue());  // Выводит: 50
}
```

Таким образом, можно сказать, что Java использует «передачу по значению ссылки», что в некотором смысле является
комбинацией передачи по значению и передачи по ссылке.

### 2 пример

![img.png](media/img9.png)

![img_1.png](media/img10.png)

# Дефолтное значение переменных класса и локальных переменных

Если переменная класса не инициализирована, то ей будет присвоено значение по умолчанию.
А если не проинициализирована локальная переменная, то код не скомпилируеться. Такая переменная не содержит значение по
умолчанию.
Это связано с тем что локальные переменные хранятся в стеке (stack), и Java не гарантирует их автоматической
инициализации.
Прежде чем выделить фрэйм JVM должна понимать, что туда сохранять. Именно по этой причине мы получим ошибку «variable
might not have been initialized», ведь если она не инициализирована, то JVM не сможет нам подготовить стэк. Поэтому при
компиляции программы умный компилятор поможет нам не допустить ошибку и не сломать всё.

Переменные класса инициализируются автоматически, так как это часть контрактов JVM и дизайна памяти в куче.
Локальные переменные требуют явной инициализации для предотвращения использования случайных или мусорных значений. Это
повышает надежность и безопасность кода.

```java
class Dog {
    private int size; //0 целые
    private String name; // null ссылки
    private boolean vactines;// false булево
    private char alias;  //0 для чара как и для числового
    private double weight; // 0.0 с плавующей точкой

    public void go() {
        int x; //  variable x might not have been initialized
        int z = x + 3;
    }
}
```

### Примитивные типы как часть объектов

Когда он используется как поле объекта, само значение примитива будет храниться в куче вместе с остальной частью
объекта. Например, если у вас есть класс `Person` с полем `int age`, то значение `age` будет храниться в куче вместе с
объектом `Person`.
Пример:

```java
public class Person {
    int age; // Примитивный тип данных внутри объекта, хранящегося в куче
}

public class Main {
    public static void main(String[] args) {
        Integer number = 5; // Обёрнутый примитивный тип, хранящийся в куче
        Person person = new Person(); // Объект, хранящийся в куче, с примитивным полем
        person.age = 25; // Примитивное значение age хранится в куче вместе с объектом person
    }
}
```

В этом примере `number` (обёрнутый `int`) и `person` (объект с примитивным полем `age`) хранятся в куче.

Хотя примитивные типы данных обычно ассоциируются с хранением на стеке, они могут храниться в куче, если являются частью
объекта или обёрнуты в соответствующие обёрточные классы. Это позволяет примитивным типам участвовать в динамическом
управлении памятью и объектно-ориентированных структурах данных, сохраняя при этом эффективность работы с данными.

### Что такое null

Как было сказано выше, переменные объектных типов, если они являются полями класса, инициализируются значениями по
умолчанию и таким значением по умолчанию является null. Но что же такое null в Java?

Первое что важно помнить – примитивные типы не могут быть null. А всё потому, что null – это особенная ссылка (
reference), которая не ссылается никуда, ни на какой объект. Поэтому, только объектная переменная может быть равна null.

Второе, что важно понимать, что null – это ссылка, reference. Я reference тоже имеют свой вес. На эту тему можно
почитать вопрос на
stackoverflow: ["Does null variable require space in memory"](https://stackoverflow.com/questions/2430655/java-does-null-variable-require-space-in-memory?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa).

В Java — null это просто значение, которое может иметь ссылка (которая по сути является ограниченным указателем). Это
означает, что ссылка ни на что не ссылается. В этом случае вы все равно потребляете пространство для ссылки. Это 4 байта
на 32-битных системах или 8 байт на 64-битных системах. Однако вы не потребляете никакого пространства для класса, на
который указывает ссылка, пока вы фактически не выделите экземпляр этого класса, чтобы указать на ссылку.

Редактировать: Что касается строки, то Stringв Java для каждого символа a требуется 16 бит (2 байта) плюс небольшое
количество накладных расходов на ведение учета, что, вероятно, не документировано и зависит от реализации.

# Типы ссылок

Если вы внимательно посмотрите на изображение структуры памяти, вы, вероятно, заметите, что стрелки, представляющие
ссылки на объекты из кучи, на самом деле относятся к разным типам. Это потому, что в языке программирования Java
используются разные типы ссылок: сильные, слабые, мягкие и фантомные ссылки. Разница между типами ссылок заключается в
том, что объекты в куче, на которые они ссылаются, имеют право на сборку мусора по различным критериям. Рассмотрим
подробнее каждую из них.

1. Сильная ссылка
   Это самые популярные ссылочные типы, к которым мы все привыкли. В приведенном выше примере со StringBuilder мы
   фактически храним сильную ссылку на объект из кучи. Объект в куче не удаляется сборщиком мусора, пока на него
   указывает сильная ссылка или если он явно доступен через цепочку сильных ссылок.
   ```
   StringBuilder builder = new StringBuilder();
    ```
2. Слабая ссылка
   Попросту говоря, слабая ссылка на объект из кучи, скорее всего, не сохранится после следующего процесса сборки
   мусора. Слабая ссылка создается следующим образом:

   ```
   WeakReference<StringBuilder> reference = new WeakReference<>(new StringBuilder());
   ```
   WeakReference отлично подойдут для хранения метаданных, например для хранения ссылки на ClassLoader. Если нет
   классов для загрузки то нет смысла хранить ссылку на ClassLoader, слабая ссылка делает ClassLoader доступным для
   удаления как только мы назначим ее вместо крепкой ссылки (Strong reference).

3. Мягкая ссылка
   Эти типы ссылок используются для более чувствительных к памяти сценариев, поскольку они будут собираться сборщиком
   мусора только тогда, когда вашему приложению не хватает памяти. Следовательно, пока нет критической необходимости в
   освобождении некоторого места, сборщик мусора не будет касаться легко доступных объектов. Java гарантирует, что все
   объекты, на которые имеются мягкие ссылки, будут очищены до того, как будет выдано исключение OutOfMemoryError. В
   документации Javadocs говорится, что «все мягкие ссылки на мягко достижимые объекты гарантированно очищены до того,
   как виртуальная машина выдаст OutOfMemoryError».

   Подобно слабым ссылкам, мягкая ссылка создается следующим образом:

    ```
   SoftReference<StringBuilder> reference = new SoftReference<>(new StringBuilder());
   ```

   Главное отличие SoftReference от WeakReference в том как сборщик с ними будет работать. Он может удалить объект в
   любой момент если на него указывают только weak ссылки, с другой стороны объекты с soft ссылкой будут собраны только
   когда JVM очень нужна память. Благодаря таким особенностям ссылочных классов каждый из них имеет свое применение.
   SoftReference можно использовать для реализации кэшей и когда JVM понадобится память она освободит ее за счет
   удаления таких объектов.

4. Фантомная ссылка
   Используется для планирования посмертных действий по очистке, поскольку мы точно знаем, что объекты больше не живы.
   Используется только с очередью ссылок, поскольку .get()метод таких ссылок всегда будет возвращаться null. Эти типы
   ссылок считаются предпочтительными для финализаторов.

Strong ссылка самая простая, так как мы используем ее в программировании изо дня в день, например в коде вида
```String s = “abc”``` переменная s это и есть strong ссылка.

Любой объект что имеет strong ссылку запрещен для удаления сборщиком мусора. Разумеется что это объекты которые нужны
Java программе. Слабые ссылки представлены классом java.lang.ref.WeakReference, вы можете определить слабую ссылку так:

```java

Counter counter = new Counter();
WeakReference weakCounter = new WeakReference(counter);
counter =null;

```

Теперь, как только вы присвоили strong ссылке counter значение null (counter = null), тот объект что создан в первой
строке становится доступным для удаления сборщиком мусора, потому что он больше не имеет strong ссылки. Cозданная Weak
ссылка weakCounter не может предотвратить удаление сборщиком объекта Counter. С другой стороны если бы это была Soft
ссылка, объект типа Counter не был бы удален до тех пор пока JVM не нуждалась бы в памяти особенно сильно. Soft ссылки в
Java представлены классом java.lang.ref.SoftReference. Пример создания SoftReference в Java

```java
Counter prime = new Counter();
SoftReference soft = new SoftReference(prime);
prime =null;
```

После обнуления strong ссылки (в 3-ей строке) на объект Counter останется только 1 мягкая ссылка которая не сможет
предотвратить удаление этого объекта сборщиком мусора, но в отличие от weak ссылки сможет отложить этот процесс до тех
пор пока не появится острая нехватка памяти. Учитывая это отличие soft ссылки от weak, первая больше подходит для кэшей,
а weak для метаданных. Хорошим примером служит класс WeakHashMap который является наследником интерфейса Map как и
классы HashMap или TreeMap, но с одной отличительной особенностью. WeakHashMap оборачивает ключи как weak ссылки, что
означает что как только не осталось strong ссылок на объект, weak ссылки которые расположены внутри WeakHashMap не
спасут от сборщика мусора.

Фантомные ссылки - третий тип ссылок, доступных в пакете java.lang.ref. Phantom ссылки представлены классом
java.lang.ref.PhantomReference. Объект на который указывают только phantom ссылки может быть удален сборщиком в любой
момент. Phantom ссылка создается точно так же как weak или soft.

```java

DigitalCounter digit = new DigitalCounter();
PhantomReference phantom = new PhantomReference(digit);
digit =null;

```

Как только вы обнулите strong ссылки на объект DigitalCounter, сборщик мусора удалит его в любой момент, так как теперь
на него ведут только phantom ссылки.

Кроме классов WeakReference, SoftReference, PhantomReference, WeakHashMap, полезно знать о классе ReferenceQueue. Вы
можете воспользоваться этим классом при создании объекта класса WeakReference, SoftReference или PhantomReference:

```java
ReferenceQueue refQueue = new ReferenceQueue();
DigitalCounter digit = new DigitalCounter();
PhantomReference phantom = new PhantomReference(digit, refQueue);

```

Ссылка на объект будет добавлена в ReferenceQueue и вы сможете контролировать состояние ссылок путем опроса
ReferenceQueue. Жизненный цикл Object хорошо представлен на этой диаграмме:
![img.png](media/img5.png)

Вот и все отличия между weak и soft ссылками в
Java. Так же мы познакомились с phantom ссылками, классом WeakHashMap и ReferenceQueue. Правильное использование ссылок
поможет при сборке мусора и в результате мы получим более гибкое управление памятью в Java.

### Ссылки на String

Ссылки на тип String в Java обрабатываются немного по- другому. Строки неизменяемы, что означает, что каждый раз, когда
вы делаете что-то со строкой, в куче фактически создается другой объект. Для строк Java управляет пулом строк в памяти.
Это означает, что Java сохраняет и повторно использует строки, когда это возможно. В основном это верно для строковых
литералов. Например:

```

String localPrefix = "297"; //1
String prefix = "297"; //2

if(prefix ==localPrefix){
    System.out.println("Strings are equal");
}
 else {
     System.out.println("Strings are different");
}
Строка localPrefix = «297» ; // 1

```

При запуске этот код распечатывает следующее:

```Strings are equal```

Следовательно, оказывается, что две ссылки типа String на одинаковые строковые литералы фактически указывают на одни и
те же объекты в куче. Однако это не действует для вычисляемых строк. Предположим, что у нас есть следующее изменение в
строке // 1 приведенного выше кода.

```java

String localPrefix = new Integer(297).toString(); //1

```

Вывод:

```Strings are different```

В этом случае мы фактически видим, что у нас есть два разных объекта в куче. Если учесть, что вычисляемая строка будет
использоваться довольно часто, мы можем заставить JVM добавить ее в пул строк, добавив .intern()метод в конец
вычисляемой строки:

```java

String localPrefix = new Integer(297).toString().intern(); //1

```

При добавлении вышеуказанного изменения создается следующий результат:

Строки равны