# Предложение GROUP BY

Предложение GROUP BY используется для определения групп выходных строк, к которым могут применяться агрегатные функции (
COUNT, MIN, MAX, AVG и SUM). Если это предложение отсутствует, и используются агрегатные функции, то все столбцы с
именами, упомянутыми в SELECT, должны быть включены в агрегатные функции, и эти функции будут применяться ко всему
набору строк, которые удовлетворяют предикату запроса. В противном случае все столбцы списка SELECT, не вошедшие в
агрегатные функции, должны быть указаны в предложении GROUP BY. В результате чего все выходные строки запроса
разбиваются на группы, характеризуемые одинаковыми комбинациями значений в этих столбцах. После чего к каждой группе
будут применены агрегатные функции. Следует иметь в виду, что для GROUP BY все значения NULL трактуются как равные, то
есть при группировке по полю, содержащему NULL-значения, все такие строки попадут в одну группу.

Если при наличии предложения GROUP BY, в предложении SELECT отсутствуют агрегатные функции, то запрос просто вернет по
одной строке из каждой группы. Эту возможность, наряду с ключевым словом DISTINCT, можно использовать для исключения
дубликатов строк в результирующем наборе.

Рассмотрим простой пример:

```sql
SELECT model,
       COUNT(model) AS Qty_model,
       AVG(price)   AS Avg_price
FROM PC
GROUP BY model;
```

В этом запросе для каждой модели ПК определяется их количество и средняя стоимость. Все строки с одинаковыми значениями
model (номер модели) образуют группу, и на выходе SELECT вычисляются количество значений и средняя цена для каждой
группы. Результатом выполнения запроса будет следующая таблица

| model | 	Qty_model | 	Avg_price        |
|-------|------------|-------------------|
| 1121  | 	3         | 	850              |
| 1232  | 	4         | 	425              |
| 1233  | 	3         | 	843,333333333333 |
| 1260  | 	1         | 	350              |

Если бы в SELECT присутствовал столбец с датой, то можно было бы вычислять эти показатели для каждой конкретной даты.
Для этого нужно добавить дату в качестве группирующего столбца, и тогда агрегатные функции вычислялись бы для каждой
комбинации значений {модель, дата}.

Существует несколько определенных правил выполнения агрегатных функций.

Если в результате выполнения запроса не получено ни одной строки (или ни одной строки для данной группы), то исходные
данные для вычисления любой из агрегатных функций отсутствуют. В этом случае результатом выполнения функций COUNT будет
нуль, а результатом всех других функций — NULL.
Данное свойство может дать не всегда очевидный результат. Рассмотрим, например, такой запрос:

```sql
SELECT 1 a WHERE
EXISTS(SELECT  MAX(price)
FROM PC
WHERE price<0);
```

Подзапрос в предикате EXISTS возвращает одну строку с NULL в качестве значения столбца. Поэтому, несмотря на то, что ПК
с отрицательными ценами нет в базе данных, запрос в примере вернет 1.
Аргумент агрегатной функции не может сам содержать агрегатные функции (функция от функции). То есть в простом запросе (
без подзапросов) нельзя, скажем, получить максимум средних значений.
Результат выполнения функции COUNT есть целое число (INTEGER). Другие агрегатные функции наследуют типы данных
обрабатываемых значений.
Если при выполнении функции SUM будет получен результат, превышающий максимально возможное значение для используемого
типа данных, возникает ошибка.
Итак, агрегатные функции, включенные в предложение SELECT запроса, не содержащего предложения GROUP BY, исполняются над
всеми результирующими строками этого запроса. Если же запрос содержит предложение GROUP BY, каждый набор строк, который
имеет одинаковые значения столбца или группы столбцов, заданных в предложении GROUP BY, составляют группу, и агрегатные
функции выполняются для каждой группы отдельно.

# Предложение HAVING

Если предложение WHERE определяет предикат для фильтрации строк, то предложение HAVING применяется после группировки для
определения аналогичного предиката, фильтрующего группы по значениям агрегатных функций. Это предложение необходимо для
проверки значений, которые получены с помощью агрегатной функции не из отдельных строк источника записей, определенного
в предложении FROM, а из групп таких строк. Поэтому такая проверка не может содержаться в предложении WHERE.

Пример 5.5.5

Получить количество ПК и среднюю цену для каждой модели, средняя цена которой менее $800

```sql

SELECT model,
       COUNT(model) AS Qty_model,
       AVG(price)   AS Avg_price
FROM PC
GROUP BY model
HAVING AVG(price) < 800;

```

В результате выполнения запроса получим:

| model | 	Qty_model | 	Avg_price |
|-------|------------|------------|
| 1232	 | 4	         | 425        |
| 1260  | 	1         | 	350       |

Заметим, что в предложении HAVING нельзя использовать псевдоним (Avg_price), используемый для именования значений
агрегатной функции в предложении SELECT. Дело в том, что предложение SELECT, формирующее выходной набор запроса,
выполняется предпоследним перед предложением ORDER BY. Ниже приведен порядок обработки предложений в операторе SELECT:

```sql
FROM
WHERE
GROUP BY
HAVING
SELECT
ORDER BY
```

Этот порядок не соответствует синтаксическому порядку общего представления оператора SELECT, который ближе к
естественному языку:

```
SELECT [DISTINCT | ALL]{*
| [<выражение для столбца> [[AS] <псевдоним>]] [,…]}
FROM <имя таблицы> [[AS] <псевдоним>] [,…]
[WHERE <предикат>]
[[GROUP BY <список столбцов>]
[HAVING <условие на агрегатные значения>] ]
[ORDER BY <список столбцов>]
```

Следует отметить, что предложение HAVING может использоваться и без предложения GROUP BY. При отсутствии предложения
GROUP BY агрегатные функции применяются ко всему выходному набору строк запроса, т.е. в результате мы получим всего одну
строку, если выходной набор не пуст.

Таким образом, если условие на агрегатные значения в предложение HAVING будет истинным, то эта строка будет выводиться,
в противном случае мы не получим ни одной строки. Рассмотрим такой пример.

Пример 5.5.6

Найти максимальную, минимальную и среднюю цену на персональные компьютеры.

Решение этой задачи дает следующий запрос:

```sql

SELECT MIN(price) AS min_price,
       MAX(price) AS max_price,
       AVG(price)    avg_price
FROM PC;

```

результатам которого будет

| min_price | 	max_price | 	avg_price |
|-----------|------------|------------|
| 350.00	   | 980.00	    | 675.00     |

Если же мы добавим в условие ограничение, скажем, на среднюю цену:

Найти максимальную, минимальную и среднюю цену на персональные компьютеры при условии, что средняя цена не превышает $
600:

```sql

SELECT MIN(price) AS min_price,
       MAX(price) AS max_price,
       AVG(price)    avg_price
FROM PC
HAVING AVG(price) <= 600;

```

то в результате получим пустой результирующий набор, т.к. 675.00 > 600.