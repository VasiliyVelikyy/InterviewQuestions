# INTERSECT

SQL оператор INTERSECT используется для возврата результатов 2 или более операторов SELECT. Однако он возвращает только
строки, выбранные всеми запросами или наборами данных. Если запись существует в одном запросе, а не в другом, она будет
опущена в результатах INTERSECT.

```sql
SELECT *
FROM product
WHERE (maker = 'A' OR maker = 'B')
  AND type = 'pc';
```

можно выразить через пересечение

```sql
SELECT *
FROM product
WHERE maker = 'A'
   OR maker = 'B'
INTERSECT
SELECT *
FROM product
WHERE type = 'pc';
```

# UNION

SQL оператор UNION используется для объединения результирующих наборов из 2 или более операторов SELECT. Он удаляет
повторяющиеся строки между различными запросами SELECT.
Каждый оператор SELECT в UNION должен иметь одинаковое количество полей в наборах результатов с одинаковыми типами
данных.

* UNION удаляет повторяющиеся строки
* Оператор UNION ALL не удаляет повторяющиеся строки

```sql
SELECT *
FROM product
WHERE (maker = 'A' AND type = 'pc')
   OR (maker = 'B' AND type = 'pc');
```

через объединение

```sql
SELECT *
FROM product
WHERE maker = 'A'
  AND type = 'pc'
UNION
SELECT *
FROM product
WHERE maker = 'B'
  AND type = 'pc';
```

### Пример - разные имена полей

Нет необходимости, чтобы соответствующие столбцы в каждом операторе SELECT имели одинаковые имена, но они должны быть с
одинаковыми, соответствующими типами данных.
Если у вас нет одинаковых имен столбцов между операторами SELECT, это становится немного сложнее, особенно если вы
хотите упорядочить результаты запроса, используя оператор ORDER BY.
Давайте посмотрим, как использовать оператор UNION с разными именами столбцов и упорядочиванием результатов запроса.
Например.

```sql
SELECT supplier_id,
       supplier_name
FROM suppliers
WHERE supplier_id > 2000
UNION
SELECT company_id,
       company_name
FROM companies
WHERE company_id > 1000
ORDER BY 1;

```

В этом SQL примере UNION, поскольку имена столбцов в двух операторах SELECT различаются, более выгодно ссылаться на
столбцы в ORDER BY по их положению в наборе результатов. В этом примере мы отсортировали результаты по supplier_id /
company_id в порядке возрастания, как обозначено ORDER BY 1. Поля supplier_id / company_id находятся в позиции № 1 в
наборе результатов.

Теперь давайте рассмотрим этот пример подробнее с данными.
Если у вас была таблица suppliers, заполненная следующими записями.

| supplier_id | supplier_name |
|-------------|---------------|
| 1000        | Microsoft     |
| 2000        | Oracle        |
| 3000        | Apple         |
| 4000        | Samsung       |

И таблица companies заполнилась следующими записями.

| company_id | company_name |
|------------|--------------|
| 1000       | Microsoft    |
| 3000       | Apple        |
| 7000       | Sony         |
| 8000       | IBM          |

И вы выполнили следующий оператор UNION.

```sql

SELECT supplier_id,
       supplier_name
FROM suppliers
WHERE supplier_id > 2000
UNION
SELECT company_id, company_name
FROM companies
WHERE company_id > 1000
ORDER BY 1;
```

Вы получите следующие результаты.

| supplier_id | supplier_name |
|-------------|---------------|
| 3000        | Apple         |
| 4000        | Samsung       |
| 7000        | Sony          |
| 8000        | IBM           |

Во-первых, обратите внимание, что запись с supplier_id, равной 3000, появляется только один раз в наборе результатов,
поскольку запрос UNION удалил повторяющиеся записи.
Во-вторых, обратите внимание, что заголовки столбцов в наборе результатов называются supplier_id и supplier_name. Это
потому, что это были имена столбцов, использованных в первом операторе SELECT в UNION.
Если бы вы хотели, вы могли бы присвоить псевдонимы столбцам следующим образом.

```sql
SELECT supplier_id   AS ID_Value,
       supplier_name AS Name_Value
FROM suppliers
WHERE supplier_id > 2000
UNION
SELECT company_id   AS ID_Value,
       company_name AS Name_Value
FROM companies
WHERE company_id > 1000
ORDER BY 1;
```

Теперь заголовки столбцов в результате будут иметь псевдоним как ID_Value для первого столбца и Name_Value для второго
столбца.

| ID_Value | Name_Value |
|----------|------------|
| 3000     | Apple      |
| 4000     | Samsung    |
| 7000     | Sony       |
| 8000     | IBM        |

# BETWEEN

Предикат BETWEEN проверяет, попадают ли значения проверяемого выражения в диапазон, задаваемый пограничными выражениями,
соединяемыми служебным словом AND. Естественно, как и для предиката сравнения, выражения в предикате BETWEEN должны быть
совместимы по типам.
Предикат

exp1 BETWEEN exp2 AND exp3
равносилен предикату

exp1 >= exp2 AND exp1 <= exp3
А предикат

exp1 NOT BETWEEN exp2 AND exp3
равносилен предикату

NOT (exp1 BETWEEN exp2 AND exp3)

# IN

Синтаксис:

```
IN::=
<Проверяемое выражение> [NOT] IN (<подзапрос>)
| (<выражение для вычисления значения>,...)
```

Предикат IN определяет, будет ли значение проверяемого выражения обнаружено в наборе значений, который либо явно
определен, либо получен с помощью табличного подзапроса. Здесь табличный подзапрос это обычный оператор SELECT, который
создает одну или несколько строк для одного столбца, совместимого по типу данных со значением проверяемого выражения.
Если целевой объект эквивалентен хотя бы одному из указанных в предложении IN значений, истинностное значение предиката
IN будет равно TRUE. Если для каждого значения Х в предложении IN целевой объект <> X, истинностное значение будет равно
FALSE. Если подзапрос выполняется, и результат не содержит ни одной строки (пустая таблица), предикат принимает значение
FALSE. Когда не соблюдается ни одно из упомянутых выше условий, значение предиката равно UNKNOWN.

```sql
SELECT model, speed, hd
FROM PC
WHERE hd IN (10, 20);
```

```sql
SELECT model, speed, hd
FROM PC
WHERE hd IN (10, 20)
  AND model IN (SELECT model
                FROM product
                WHERE maker = 'A');
```
