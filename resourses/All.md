### Память в Java

Стек (Stack)
Стековая память отвечает за хранение ссылок на объекты кучи и за хранение типов значений (также известных в Java как
примитивные типы), которые содержат само значение, а не ссылку на объект из кучи.

Кроме того, переменные в стеке имеют определенную видимость, также называемую областью видимости. Используются только
объекты из активной области. Например, предполагая, что у нас нет никаких глобальных переменных (полей) области
видимости, а только локальные переменные, если компилятор выполняет тело метода, он может получить доступ только к
объектам из стека, которые находятся внутри тела метода. Он не может получить доступ к другим локальным переменным, так
как они не входят в область видимости. Когда метод завершается и возвращается, верхняя часть стека выталкивается, и
активная область видимости изменяется.

Возможно, вы заметили, что на картинке выше отображено несколько стеков памяти. Это связано с тем, что стековая память в
Java выделяется для каждого потока. Следовательно, каждый раз, когда поток создается и запускается, он имеет свою
собственную стековую память и не может получить доступ к стековой памяти другого потока.

#### Сборщики мусора

Для минимизации задержек при работе с большими кучами памяти наиболее подходящим выбором среди перечисленных является
G1 (Garbage-First) Garbage Collector.

Почему G1?
G1 был разработан как замена для CMS (Concurrent Mark Sweep) с целью минимизации пауз, особенно при работе с большими
кучами памяти.
G1 разделяет кучу на регионы и использует подход прогнозирования пауз, что позволяет ему эффективно управлять временем
сборки мусора.
Он проводит большую часть работы по сборке мусора параллельно с выполнением приложения, сводя к минимуму паузы.
Другие сборщики мусора:

- Serial GC: Использует однопоточный сбор и приостанавливает приложение на все время сборки, что не подходит для
  приложений с большими кучами и требованиями к низкой задержке.
- Parallel GC: Использует несколько потоков для работы, но все еще вызывает паузы, что также может быть нежелательно при
  работе с большими объемами памяти.
- CMS: Работает частично параллельно с приложением, но все же имеет финальные фазы остановки мира (STW), что может
  приводить к задержкам.
- G1 — это оптимальный выбор среди перечисленных для работы с большими кучами и минимизации задержек в JVM-приложениях.

#### Сильные, слабые ссылки

<https://habr.com/ru/articles/549176/>

### Отличие synchronize, volatile, static, transient

Ключевое слово synchronized используется в Java для обеспечения того, чтобы только один поток исполнял блок кода
одновременно.

- synchronized: Используется для синхронизации доступа к критическим секциям кода, гарантируя, что только один поток
  может
  выполнить этот блок кода в любой момент времени.
- volatile: Обозначает переменную, значение которой может изменяться разными потоками, и обеспечивает видимость
  изменений
  для всех потоков, но не блокирует доступ.
- static: Определяет статические переменные и методы, которые принадлежат классу, а не экземпляру.
- transient: Используется для обозначения полей, которые не должны быть сериализованы.

### Отличие wait(), sleep(), yield(), join()

Метод wait() класса Object используется для того, чтобы заставить текущий поток ждать, пока другой поток не вызовет
notify() или notifyAll() на том же объекте.

- wait(): Останавливает выполнение текущего потока до тех пор, пока другой поток не вызовет notify() или notifyAll() на
  объекте, на котором был вызван wait(). Этот метод должен вызываться внутри синхронизированного блока или метода.
- sleep(): Приостанавливает выполнение текущего потока на заданное количество миллисекунд, но не освобождает монитор
  блокировки.
- yield(): Предлагает текущему потоку добровольно уступить процессор другим потокам, но не гарантирует, что поток
  действительно прекратит выполнение.
- join(): Используется для ожидания завершения выполнения другого потока.

### Какая структура данных наилучшим образом подходит для реализации кэша, где важны как быстрый доступ к элементам, так и возможность учитывать порядок их использования?

Наилучшим выбором для реализации кэша, где важны как быстрый доступ к элементам, так и возможность учитывать порядок их
использования, будет LinkedHashMap.

- LinkedHashMap: Это структура данных, которая сочетает в себе преимущества хэш-таблицы (для быстрого доступа) и
  связного списка (для поддержания порядка вставки или порядка доступа). Она идеально подходит для реализации кэша с
  политикой, такой как LRU (Least Recently Used), так как может автоматически удалять самые старые элементы при
  достижении определённого размера.

- HashMap: Обеспечивает быстрый доступ к элементам, но не сохраняет порядок вставки или использования элементов.

- ArrayList: Поддерживает порядок элементов, но не предназначена для быстрого доступа к элементам на основе ключей, как
  это делает хэш-таблица.

- TreeSet: Поддерживает отсортированный порядок элементов, но используется для хранения уникальных значений, а не для
  ассоциативных данных (ключ-значение).

Таким образом, правильный ответ — LinkedHashMap.

### Какой механизм в ООП позволяет одному классу использовать свойства и методы другого класса?

- При наследовании один класс (наследник) получает доступ к свойствам и методам другого класса (родителя), что позволяет
переиспользовать код и расширять функциональность базового класса.
- Инкапсуляция: это механизм сокрытия реализации и защиты данных класса от внешнего вмешательства, предоставляя доступ
только через публичные методы.
- Полиморфизм: это возможность использования одного и того же интерфейса для разных типов объектов, что позволяет объектам
разных классов реагировать на одни и те же вызовы методов по-разному.
- Композиция: это механизм, при котором один класс включает объекты других классов в качестве своих полей, что позволяет
ему использовать функциональность других классов.
- Абстракция: это процесс выделения общих характеристик объектов и их представление через абстрактные классы или интерфейсы.

