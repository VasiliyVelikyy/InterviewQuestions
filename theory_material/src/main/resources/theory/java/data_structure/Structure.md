### Что такое коллизия

Когда два разных значения (два разных объекта) имеют одинаковый хэш-код при использовании функции хэширования.
Это может привести к тому, что разные элементы будут сохранены в одной и той же ячейке таблицы хешей, что может вызвать
конфликты при поиске элементов.
Дело в том, что hashcode отображается в типе Integer, который, в свою очередь, имеет диапазон от -2147483648 до
2147483647, то есть приблизительно 4 миллиарда разных целых чисел.

Этот диапазон огромен, тем не менее, не бесконечен. Поэтому, возможны ситуации когда два совершенно разных объекта имеют
одинаковый хеш-код. Это весьма маловероятно, но возможно.

Увеличивать частоту одинаковых хеш-кодов может еще плохо реализованная хеш-функция, которая будет, к примеру, возвращать
числа в небольшом диапазоне, что увеличит шанс коллизий.

Для борьбы с коллизией нужно иметь хорошую имплементацию метода hashCode, чтобы разброс значений был максимальным и шанс
повторения значений был минимальным.

### Что такое HashMap ?

HashMap — это структура данных, которая хранит элементы в виде пар ключ-значение. Она использует хеш-таблицу для
эффективного поиска, вставки и удаления элементов. Ключи в ней уникальны, а значения могут дублироваться. Один из
ключевых аспектов ее использования заключается в возможности доступа к значениям очень быстро по их ключам.

Как работает HashMap

Когда пара ключ-значение добавляется в нее, ключ проходит через хеш-функцию, которая вычисляет индекс в массиве, где
должно быть хранится значение. Этот процесс позволяет ей эффективно находить значение по ключу, обеспечивая доступ за
константное время O(1) в идеальном случае. Однако, в случае коллизий хеш-функций (когда разные ключи имеют одинаковый
хеш-код и, следовательно, могут быть отнесены к одному и тому же индексу массива), она использует структуру данных "
связный список" или "красно-черное дерево" (начиная с Java 8) для хранения всех пар ключ-значение, относящихся к одному
индексу. Это немного замедляет процесс поиска до O(log n) для красно-черного дерева в худшем случае.
В случае когда плохо реализован хешкод - все элементы могут попасть в 1 бакет. И наихудщее время поиска линейное O(n)
так как нужно перебрать все значения.

Особенности HashMap

- Не гарантирует порядка элементов: Порядок хранения элементов не гарантирован, и при добавлении новых элементов порядок
  может измениться.
- null значения: Позволяет использовать null как ключ и как значение, но только один null ключ, в то время как значений
  null может быть много.
- Несинхронизированность: По умолчанию не является потокобезопасной. Если несколько потоков одновременно доступают к ней
  и хотя бы один из потоков изменяет карту, это должно быть синхронизировано внешним образом.

   ``` import java.util.HashMap;
       
       public class Example {
           public static void main(String[] args) {
               // Создание HashMap
               HashMap<String, Integer> map = new HashMap<>();
       
               // Добавление элементов в HashMap
               map.put("Ключ1", 100);
               map.put("Ключ2", 200);
               map.put("Ключ3", 300);
       
               // Получение значения по ключу
               int value = map.get("Ключ2"); // 200
       
               // Проверка наличия ключа или значения
               boolean keyExists = map.containsKey("Ключ1"); // true
               boolean valueExists = map.containsValue(300); // true
       
               // Удаление элемента
               map.remove("Ключ3");
           }
       }
   ```

### Что будет, если элемент, участвующий в контракте с HashCode, изменит свое значение?

Если элемент, который участвует в подсчете хеш-кода был изменен, то и сам хеш-код объекта будет изменен (при хорошей
хеш-функции). Поэтому в HashMap рекомендуется использовать иммутабельные (неизменяемые) объекты в качестве ключа, ведь
их внутреннее состояние (поля) невозможно изменить после создания. Соответственно их хеш-код также не преобразуется
после создания.

Если же в качестве ключа использовать изменяемый объект, то при изменении полей данного объекта изменится его хеш-код и
как итог можно потерять данную пару в HashMap. Ведь она будет сохранена в бакете для первоначального хеш-кода, а после
изменения его поиск будет производиться в другом бакете.

### В чем разница меду hashmap и hashtable ?

HashMap и Hashtable являются двумя структурами данных, предназначенными для хранения данных в форме пар "ключ-значение",
но между ними есть несколько ключевых отличий:

Синхронизация

- Hashtable является потокобезопасным благодаря синхронизации методов. Это означает, что его безопасно использовать в
  многопоточных приложениях без внешней синхронизации.
- HashMap не является потокобезопасным и не обеспечивает синхронизацию методов. Это делает его более быстрым в средах с
  однопоточным доступом. Для использования в многопоточных приложениях необходимо обеспечивать внешнюю синхронизацию или
  использовать ConcurrentHashMap.

Null значения

- HashMap позволяет один его ключ и множество его значений.
- Hashtable не позволяет такой ключи и такие значения. Попытка вставить его в Hashtable приведет к выбросу
  NullPointerException.
  HashMap не может посчитать hash-сумму от null. Но вместо этого для таких ключей просто используется бакет номер 0.
  Наследование

- HashMap является частью новой коллекционной фреймворка, введенной в Java 2, и наследует абстрактный класс AbstractMap.
- Hashtable была введена в ранних версиях Java и наследует класс Dictionary. Хотя она была реорганизована в
  коллекционный фреймворк, она считается устаревшей для нового кода.

Итератор и Enumerator

- HashMap предоставляет итераторы, которые используются для перебора элементов. Итераторы HashMap являются fail-fast,
  что означает, что они выбросят ConcurrentModificationException, если структура HashMap будет изменена в любое время
  после создания итератора, кроме его собственных методов remove.
- Hashtable предоставляет как итератор, так и Enumerator. Enumerator для Hashtable не является fail-fast.

Производительность

- HashMap обычно предлагает лучшую производительность в сравнении с Hashtable, поскольку отсутствие синхронизации делает
  его быстрее.

Резюме

- Используйте HashMap для не потокобезопасных реализаций без null ключей и значений.
- Используйте Hashtable в многопоточных приложениях, где требуется потокобезопасность и отсутствие null ключей и
  значений.
- В современном Java коде предпочтение обычно отдается ConcurrentHashMap для потокобезопасных реализаций и HashMap для
  остальных случаев за счет лучшей производительности и более широкой функциональности.

### Какая структура данных обеспечивает наиболее эффективное добавление и удаление элементов в начале списка?

Наиболее эффективное добавление и удаление элементов в начале списка обеспечивается структурой LinkedList.

Причина в том, что в LinkedList элементы связаны ссылками, и для добавления или удаления элемента в начале списка
требуется лишь обновление ссылок, что выполняется за O(1). В отличие от этого, в ArrayList удаление или добавление
элемента в начале списка требует сдвига всех остальных элементов, что занимает O(n) времени.

Другие структуры данных в этом контексте:

- ArrayList: добавление и удаление элементов в начале списка занимает O(n), поскольку нужно сдвигать все последующие
  элементы.
- HashSet: это структура данных для хранения уникальных элементов, и она не предназначена для работы с элементами в
  определенном порядке, поэтому она не подходит для данной задачи.
- ArrayDeque: добавление и удаление элементов в начале очереди происходит за O(1), но эта структура больше ориентирована
  на работу с очередями и двухсторонними очередями, а не на произвольный доступ к элементам.
  Таким образом, для эффективного добавления и удаления элементов в начале списка подходит LinkedList.

### В чем разница между LinkedList и ArrayList?

- Манипуляции.
  В обоих случаях существует разница в скорости манипулирования массивами. ArrayList медленнее манипулируют массивами,
  чем LinkedList. Это связано с тем, что LinkedList основан на узлах (node-based) и не требует большого смещения битов.
- Доступ.
  ArrayList быстрее хранят и извлекают данные. С другой стороны, LinkedList поддерживает более быструю обработку данных.
- Реализация.
  ArrayList реализует только список, а LinkedList реализует и список, и очередь. LinkedList также часто используется в
  качестве очередей.
- Внутренняя реализация.
  В ArrayList элементы хранятся в динамическом массиве, тогда как LinkedList используют двусвязный (doubly-linked)
  список.
  Когда использовать ArrayList и LinkedList?
  ArrayList подходит для работы с коллекцией, доступной только для чтения, а LinkedList подходит для работы с
  коллекцией, допускающей различные модификации данных, такие как добавление и удаление.

### HashSet

HashSet внутри Java работает по принципу хэш-таблицы. Хэш-таблица - это структура данных, которая позволяет быстро
добавлять, удалять и искать элементы. В HashSet каждый элемент имеет свой уникальный хэш-код, который используется для
определения его местоположения в хэш-таблице.

HashSet содержит массив элементов и список связанных списков (bucket), где каждый элемент помещается в соответствующий
bucket на основе его хэш-кода. Когда элемент добавляется в HashSet, сначала вычисляется его хэш-код, затем он помещается
в bucket, соответствующий этому хэш-коду. Если bucket пустой, элемент просто добавляется в него. Если bucket уже
содержит элементы, то новый элемент добавляется в конец списка связанных элементов.

При поиске элемента в HashSet, сначала вычисляется его хэш-код. Затем HashSet проверяет bucket, соответствующий этому
хэш-коду, чтобы найти элемент с таким же хэш-кодом. Если bucket не пустой, HashSet перебирает все элементы в списке
связанных элементов, чтобы найти элемент с таким же значением. Если элемент найден, метод возвращает true, иначе -
false.

#### Почему HashSet не трансформируется в красно-чёрное дерево?

Поскольку HashSet использует хэширование для хранения элементов, порядок элементов внутри HashSet не сохраняется.
Однако, HashSet обеспечивает O(1) сложность поиска элемента, что делает его эффективным выбором для задач, связанных с
быстрой проверкой наличия элемента в коллекции.

Если необходимо использовать Set с сохранением порядка элементов, можно использовать LinkedHashSet, который использует
двусвязный список для хранения элементов и сохраняет порядок добавления элементов.

HashSet сам по себе не является ни массивом, ни деревом — он просто использует HashMap для хранения данных.
Преобразование связанного списка в красно-чёрное дерево происходит внутри HashMap , а не в самом HashSet.

Если в HashSet добавляется много элементов, которые попадают в один и тот же bucket (из-за коллизий хэш-функции), то
HashMap может преобразовать этот bucket из связанного списка в красно-чёрное дерево. Однако это внутренняя деталь
реализации HashMap, и она никак не влияет на внешний интерфейс HashSet.